#' @title AssociationTest
#' @description Run association test for features with alternative expressed pairs. Features that have similar expression pattern with the 'test feature' and show different expression pattern with the 'binding feature' will be prioritized.
#' @param object Seurat object
#' @param features Vector of features. 
#' @param assay Work assay.
#' @param min.cells Features detected in few than minimal number of cells will be skipped. Default is 10.
#' @param test.features The test features. 
#' @param test.assay The test assay. This option is required.
#' @param bind.feature The bind feature. 
#' @param bind.assay The binding assay. If not set will use the test.assay instead.
#' @param wm.name Weight matrix name, this matrix (graph) usually be generated by \code{\link{RunAutoCorr}}.
#' @param cells Calculate scores for predefined cells. Will reconstruct the SNN graph and weight matrix for these cells with 'reduction' space (usually be pca or harmony). Only weight matrix that calculated by SNN is supported if cells/idents/node is defined.
#' @param perm Permutations for evaluating mean and sd of D/L scores. Default is 100.
#' @param seed Seed for generate random number. Default is 999.
#' @param threads Threads. If set to 0 (default), will auto check the CPU cores and set threads = number of CPU cores -1.
#' @param versbose Print log message. Default is TRUE.
#' @param debug Print debug message. Will auto set thread to 1. Default is FALSE.
#' @param reduction Dimension reduction name for constructing SNN graph and weight matrix. Default is 'pca'. This and following parameters only actived when cells is set, because need to recalculate the SNN graph for the defined cells. 
#' @param dims Dimensions of reduction used to construct SNN graph.
#' @param k.param Defines k for the k-nearest neighbor algorithm. This one and following parameters will passed to Seurat::FindNeighbors.
#' @param prune.SNN Sets the cutoff for acceptable Jaccard index when computing the neighborhood overlap for the SNN construction. Any edges with values less than or equal to this will be set to 0 and removed from the SNN graph. Essentially sets the stringency of pruning (0 --- no pruning, 1 --- prune everything). Default is 1/50.
#' @param nn.method Method for nearest neighbor finding. Options include: rann, annoy(default).
#' @param annoy.metric Distance metric for annoy. Options include: euclidean (default), cosine, manhattan, and hamming
#' @param n.trees More trees gives higher precision when using annoy approximate nearest neighbor search. Default is 50.
#' @param nn.eps Error bound when performing nearest neighbor seach using RANN; default of 0.0 implies exact nearest neighbor search
#' @importFrom Matrix sparseMatrix
#' @importFrom data.table rbindlist
#' @export
AssociationTest <- function(object = NULL,
                            features = NULL,
                            assay = NULL,
                            layer = "data",
                            min.cells = 10,
                            test.assay = NULL,
                            test.features = NULL,
                            bind.assay = NULL,
                            bind.feature = NULL,
                            wm.name = NULL,
                            perm=100,
                            seed=999,
                            cells = NULL,
                            threads = 0,
                            verbose = TRUE,
                            debug = FALSE,
                            reduction = "pca",
                            dims = 1:20,
                            k.param = 20,
                            prune.SNN = 1/50,
                            return.dist = FALSE
                            )
{
  tt <- Sys.time()
  
  assay <- assay %||% DefaultAssay(object)
  if (isTRUE(verbose)) {
    message("Working on assay ", assay, ".")
  }

  if (is.null(test.assay)) {
    stop("\"test.assay\" not set.")
  }
  if (is.null(bind.assay)) {
    bind.assay <- test.assay
  }

  if (is.null(features)) {
    stop("\"features\" is not set.")
  }

  if (is.null(test.features)) {
    stop("\"test.features\" is not set.")    
  }

  if (is.null(bind.feature)) {
    stop("\"bind.feature\" is not set.")    
  }

  if (length(bind.feature) > 1) {
    stop("\"bind.feature\" only allow one value.")
  }

  old.assay <- DefaultAssay(object)
  DefaultAssay(object) <- assay
  features <- intersect(features, rownames(object))

  if (length(features) < 1) {
    stop("No feature.")
  }    

  cells0 <- cells %||% colnames(object)
  cells0 <- intersect(cells0, colnames(object))
  if (length(cells0) < 1) {
    stop("No cells.")
  }
  
  if (isTRUE(verbose)) {
    message("Processing ", length(features), " features.")
  }
  
  x <- FetchData1(object, assay = assay, layer = layer, vars = features)
  y <- FetchData1(object, assay = test.assay, layer = layer, vars = test.features)
  z <- FetchData1(object, assay = bind.assay, layer = layer, vars = bind.feature)
  x <- x[cells0, features]
  y <- y[cells0, test.features]
  z <- z[cells0, bind.feature]
  
  threads <- getCores(threads)
  if (threads > length(features)) {
    threads <- length(features)
  }  
  if (isTRUE(verbose)) {
    message("Using ", threads, " threads.")
  }
  
  if (is.null(cells)) {
    wm.names <- grep("_wm$", names(object), value = TRUE)
    if (length(wm.names) == 0) {
      stop("No weight matrix found. Perform RunAutoCorr() first.")
    }
    wm.name <- wm.name %||% wm.names[1L]
    if (wm.name %ni% names(object)) {
      stop("No weight matrix found. Perform RunAutoCorr() first.")
    }
    if (verbose) {
      message("Use predefined weight matrix \"", wm.name, "\"", ".")
    }
    W <- object[[wm.name]]

    ## cell order may be changed due to merge, here reorder them
    W <- W[cells0, cells0]
  } else {
    if (verbose) {
      message("Construct SNN graph for cells with \"", reduction, "\"", ".")
    }
    ## cells <- intersect(cells, colnames(object))
    data.use <- Embeddings(object[[reduction]])
    data.use <- data.use[cells0, dims]
    ng <- FindNeighbors(object = data.use,
                        k.param = k.param,
                        compute.SNN = TRUE,
                        prune.SNN = prune.SNN,
                        nn.method = nn.method,
                        annoy.metric = annoy.metric,
                        nn.eps = 0,
                        l2.norm = FALSE, cache.index = FALSE, verbose = FALSE)
    snn <- ng[['snn']]
    W <- GetWeights(snn = snn, prune.SNN = prune.SNN)  
  }
  x <- as.matrix(x)
  x <- as(x, "CsparseMatrix")

  if (length(test.features) == 1) {
    if (length(features) == 1) {
      ta <- .Call("association_test1", x, y, z, W, perm, FALSE)
    } else {
      ta <- .Call("association_test2", x, y, z, W, perm, threads)
    }
    if (length(ta) == 1) stop(ta[[1]])
    pval <- pt(ta[[3]], df = perm - 1, lower.tail = FALSE)
    df <- data.frame(feature = features, test.feature = test.features, bind.feature = bind.feature, I1 = ta[[1]], I2 = ta[[2]], t = ta[[3]], pval = pval)
  } else {
    sl <- lapply(X = seq_along(test.features),
                 FUN = function(i) {
                   if (length(features) == 1) {
                     ta <- .Call("association_test1", x, y[,i], z, W, perm, FALSE)
                   } else {
                     ta <- .Call("association_test2", x, y[,i], z, W, perm, threads)
                   }
                   if (length(ta) == 1) stop(ta[[1]])
                   pval <- pt(ta[[3]], df = perm - 1, lower.tail = FALSE)
                   df <- data.frame(feature = features, test.feature = test.features[i], bind.feature = bind.feature, I1 = ta[[1]], I2 = ta[[2]], t = ta[[3]], pval = pval)
                   df
                 }
                 )
    df <- rbindlist(sl)
  }
  
  if (nrow(df) > 10) {
    df[["padj"]] <- p.adjust(df[["pval"]], method = "BH")
  }

  gc()

  DefaultAssay(object) <- old.assay
  tt <- Sys.time()-tt
  if (isTRUE(verbose)) {
    message("Runtime : ",format(tt), ".");
  }
  df
}
