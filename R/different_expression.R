#' @title FindDEP
#' @description Find different expression pattern of same feature in different cell groups. Only used for integrated data.
#' @param object Seurat object.
#' @param ident.1 Identify class to test, if not set will compare all groups one by one
#' @param ident.2 A second class for comparsion. If NULL (default), use all other cells for comparison.
#' @param cells.1 Vector of cell names belong to group 1. Conflict with ident.1
#' @param cells.2 Vector of cell names for comparsion. Conflict with ident.2
#' @param assay Assay for test features. Default assay will be used if not set.
#' @param reduction Dimension reduction name for constructing SNN graph and weight matrix. Default is 'pca'. This and following parameters only actived when cells is set, because need to recalculate the SNN graph for the defined cells. 
#' @param features Vector of features to calculate. Default is AutoCorrFeatures(object).
#' @param assay Work assay.
#' @param idents Specify idents to compare. If not set will use Idents(object).
#' @param min.cells Features detected in few than minimal number of cells will be skipped. Default is 10.
#' @param layer Data layer to use, default is 'data'.
### @param wm.name Weight matrix name, this matrix (graph) generated by \code{\link{RunAutoCorr}}.
#' @param mode Test mode.
#' @param perm Permutations for evaluating mean and sd of D scores. Default is 100.
#' @param seed Seed for generate random number. Default is 999.
#' @param threads Threads. If set to 0 (default), will auto check the CPU cores and set threads = number of CPU cores -1.
#' @param versbose Print log message. Default is TRUE.
#' @param return.thresh Only return markers that have a raw p-value < return.thresh. Default is 0.01.
#' @param debug Print debug message. Will auto set thread to 1. Default is FALSE.
#' @param dims Dimensions of reduction used to construct SNN graph.
#' @param k.param Defines k for the k-nearest neighbor algorithm. In default, k.param = 30
#' @param prune.SNN Sets the cutoff for acceptable Jaccard index when computing the neighborhood overlap for the SNN construction. Any edges with values less than or equal to this will be set to 0 and removed from the SNN graph. Essentially sets the stringency of pruning (0 --- no pruning, 1 --- prune everything). Default is 1/50.
#' @param filter Cutoff value for imputation. Value smaller than this cutoff will be removed.
#' @param ... Parameters pass to FindNeighbors().
#' @importFrom Matrix sparseMatrix
#' @export
FindDEP <- function(object = NULL,
                   ident.1 = NULL,
                   ident.2 = NULL,
                   cells.1 = NULL,
                   cells.2 = NULL,
                   reduction = "pca",
                   features = NULL,
                   assay = NULL,
                   idents = NULL,
                   node = NULL,
                   min.cells = 10,
                   layer = "data",
                   mode = c(1,2),
                   return.thresh =0.01,
                   perm=100,
                   seed=999,
                   threads = 0,
                   verbose = TRUE,
                   debug = FALSE,
                   dims = 1:20,
                   k.param = 30,
                   prune.SNN = 1/50,
                   filter=0.001,
                   setLog = TRUE,
                   ...
                   )
{
  if (is.null(object)) stop("No object specified.")

  mode <- mode[1L]
  assay <- assay %||% DefaultAssay(object)
  tt <- Sys.time()
  
  if (!is.null(ident.1) & !is.null(cells.1)) {
    stop("cells.1 is conflict with ident.1.")
  }

  if (!is.null(ident.2) & !is.null(cells.2)) {
    stop("cells.2 is conflict with ident.2.")
  }

  if (!is.null(ident.1)) {
    cells.1 <- colnames(object)[which(Idents(object) == ident.1)]
    if (is.null(cells.1)) stop("No ident.1 found")
  }

  if (!is.null(ident.2)) {
    cells.2 <- colnames(object)[which(Idents(object) == ident.2)]
    if (is.null(cells.2)) stop("No ident.2 found")
  }

  features <- features %||% AutoCorrFeatures(object)
  features <- intersect(features, rownames(object))
    
  threads <- getCores(threads)

  if (isTRUE(verbose) & isTRUE(setLog)) {
    message("Processing ", length(features), " features.")
  }

  if (is.null(cells.1)) {
    if (is.null(idents) & is.null(node)) {
      message("No cells.1/ident.1/idents defined. Will perform FindDEP for Idents(object).")
    }

    if (is.null(x = node)) {
      if (is.null(idents)) {
        idents.all <- sort(x = unique(x = Idents(object = object)))
      } else {
        idents.all <- sort(x = unique(x = object[[]][[idents]]))
      }
    } else {
      ## node paramenter inhert from Seurat v5.0.0, check Seurat::FindAllMarkers for details
      if (!PackageCheck('ape', error = FALSE)) {
        stop("Install ape package")
      }
      tree <- Seurat::Tool(object = object, slot = 'BuildClusterTree')
      if (is.null(x = tree)) {
        stop("Please run 'BuildClusterTree' before finding markers on nodes")
      }
      descendants <- Seurat:::DFT(tree = tree, node = node, include.children = TRUE)
      all.children <- sort(x = tree$edge[, 2][!tree$edge[, 2] %in% tree$edge[, 1]])
      descendants <- MapVals(
        vec = descendants,
        from = all.children,
        to = tree$tip.label
      )
      drop.children <- setdiff(x = tree$tip.label, y = descendants)
      keep.children <- setdiff(x = tree$tip.label, y = drop.children)
      orig.nodes <- c(
        node,
        as.numeric(x = setdiff(x = descendants, y = keep.children))
      )
      tree <- ape::drop.tip(phy = tree, tip = drop.children)
      new.nodes <- unique(x = tree$edge[, 1, drop = TRUE])
      idents.all <- (tree$Nnode + 2):max(tree$edge)
    }

    genes.de <- list()
    messages <- list()
    for (i in 1:length(x = idents.all)) {
      message("Calculating cluster ", idents.all[i])
      genes.de[[i]] <- tryCatch(
        expr = {
          FindDEP(
            object = object,
            ident.1 = if (is.null(x = node)) {
              idents.all[i]
            } else {
              tree
            },
            ident.2 = if (is.null(x = node)) {
              NULL
            } else  {
              idents.all[i]
            },
            reduction = reduction,
            assay = assay,
            features = features,
            layer = layer,
            mode = mode[1L],
            min.cells = min.cells,
            return.thresh = return.thresh,
            threads = threads,
            verbose = verbose,
            dims = dims,
            k.param = k.param,
            prune.SNN = prune.SNN,
            perm = perm,
            seed = seed,
            debug = debug,
            filter=filter,
            setLog = FALSE,
            ...
          )
        },
        error = function(cond) {
          return(cond$message)
        }
      )
      if (is.character(x = genes.de[[i]])) {
        messages[[i]] <- genes.de[[i]]
        genes.de[[i]] <- NULL
      }
    }
    
    if (length(x = messages) > 0) {
      warning("The following tests were not performed: ", call. = FALSE, immediate. = TRUE)
      for (i in 1:length(x = messages)) {
        if (!is.null(x = messages[[i]])) {
          warning("When testing ", idents.all[i], " : ", messages[[i]], call. = FALSE, immediate. = TRUE)
        }
      }
    }
    
    df <- data.frame()
    for (i in 1:length(x = idents.all)) {
      if (is.null(x = unlist(x = genes.de[i]))) {
        next
      }
      gde <- genes.de[[i]]
      if (nrow(x = gde) > 0) {
        if (nrow(x = gde) > 0) {
          gde$cluster <- idents.all[i]
        }
        if (nrow(x = gde) > 0) {
          df <- rbind(df, gde)        
        }
      }
    }
    
    rownames(x = df) <- make.unique(names = as.character(x = df$feature))
    
  } else {

    if (is.null(cells.2)) {
      cells.2 <- setdiff(colnames(object), cells.1)
    }
    
    ValidateCellGroups(object, cells.1, cells.2, min.cells)
  
    x <- GetAssayData1(object, assay = assay, layer = layer)
    cells <- c(cells.1,cells.2)
    x <- x[features,cells]    
    if (mode == 2) {
      x[,cells.1] <- 0
    }
    
    data.use <- Embeddings(object[[reduction]])
    data.use <- data.use[cells, dims]
    k.param0 <- k.param
    if (k.param == 0) {
      k.param0 <- as.integer(length(cells)*0.001)
      if (k.param0 < 20) {
        k.param0 <- 20
      }
      prune.SNN <- 1/(2*k.param0 - 1)
    }
    if (verbose & setLog) {
      message(paste0("Construct SNN graph for all cells with \"", reduction, "\"", ", k.param = ", k.param0, ", prune.SNN = ", prune.SNN, "."))
    }

    ng <- FindNeighbors(object = data.use,
                        k.param = k.param0,
                        compute.SNN = TRUE,
                        prune.SNN = prune.SNN, 
                        cache.index = FALSE, verbose = FALSE)
    snn <- ng[['snn']]
    W <- GetWeights(snn = snn, prune.SNN = prune.SNN)

    if (verbose & setLog) {
      message("Imputating pesudo-cells ..")
    }

    x0 <- x[,cells.1]
    rs <- Matrix::rowSums(x0>0)
    idx <- which(rs >= min.cells)
    features1 <- rownames(x0)[idx]
    features <- intersect(features, features1)
    x <- x[features,]
    x0 <- x[,cells.1]    
    y0 <- ImputationByWeight(X = x, cells = cells.1, W = W, filter=filter)
    
    if (k.param == 0) {
      k.param0 <- as.integer(length(cells.1)*0.001)
      if (k.param0 < 20) {
        k.param0 <- 20
      }
      prune.SNN <- 1/(2*k.param0 - 1)
    }

    if (verbose & setLog) {
      message(paste0("Reconstruct SNN graph for test cells only, k.param = ", k.param0, ", prune.SNN = ", prune.SNN, "."))
    }

    data.use <- Embeddings(object[[reduction]])
    data.use <- data.use[cells.1, dims]
    ng <- FindNeighbors(object = data.use,
                        k.param = k.param0,
                        compute.SNN = TRUE,
                        prune.SNN = prune.SNN,
                        cache.index = FALSE, verbose = FALSE)
    snn <- ng[['snn']]
    W <- GetWeights(snn = snn, prune.SNN = prune.SNN)

    if (verbose & setLog) {
      message("Performing spatial dissimilarity test..")
    }

    idx <- match(features, rownames(x0))

    ta <- .Call("D_test_v2", x0, y0, W, perm, threads, idx, idx, 0, FALSE, seed, debug)
    
    rm(x0)
    rm(y0)
    
    if (length(ta) == 1) stop(ta[[1]])

    e <- ta[[1]]
    tval <- ta[[2]]
    pval <- pt(tval, df = perm - 1, lower.tail = TRUE)
    df <- data.frame("feature" = features, "D" = e,"pval" = pval, "padj" = p.adjust(pval, method = "BH"))
    
    rownames(df) <- features

    rm(ta)

    gc()

  }
  if (isTRUE(setLog)) {
    features <- head(features)
    object <- LogSeuratCommand(object)
    
    tt <- Sys.time()-tt
    if (isTRUE(verbose)) {
      message("Runtime : ",format(tt), ".");
    }
  }

  if (!is.null(return.thresh)) {
    df <- subset(df, pval < return.thresh)
  }

  df
}

buildNNWeight <- function(data, cells.1, cells.2, k.param, l2 = FALSE)
{
  l1 <- length(cells.1)
  l2 <- length(cells.2)
  knn1 <- buildKNN(data = data[cells.1,], query = data[cells.2, ], k.param = k.param)
  mat1 <- sparseMatrix(p = as.vector(c(0,seq_along(1:length(cells.2))) * k.param ), j = as.vector(t(knn1$idx)), x = 1, dims = c(l2,l1))
  knn2 <- buildKNN(data = data[cells.2,], query = data[cells.1, ], k.param = k.param)
  mat2 <- sparseMatrix(p = as.vector(c(0,seq_along(1:length(cells.1))) * k.param ), j = as.vector(t(knn2$idx)), x = 1, dims = c(l1,l2))

  mat <- t(mat1) + mat2
  mat <- mat > 1
  rownames(mat) <- cells.1
  colnames(mat) <- cells.2
  mat2@x <- as.vector(t(knn2$dist))
  mat <- mat * mat2
  rm(mat1)
  rm(mat2)
  rm(knn1)
  rm(knn2)

  mat <- drop0(mat)
  mat <- mat[which(rowSums(mat) > 0), which(colSums(mat) > 0)]

  mat@x <- 1/mat@x
  mat <- t(mat)
  W <- mat/rowSums(mat)
  W <- t(W)
  W
}
#'@export
buildNNWeight_v2 <- function(data, cells.1, cells.2, k.param)
{
  l1 <- length(cells.1)
  l2 <- length(cells.2)
  cells <- rownames(data)
  lc <- length(cells)
  
  knn1 <- buildKNN(data = data, query = data[cells.2, ], k.param = k.param)
  mat1 <- sparseMatrix(p = as.vector(c(0,seq_along(1:length(cells.2))) * k.param ), j = as.vector(t(knn1$idx)), x = 1, dims = c(l2,lc))
  rownames(mat1) <- cells.2
  colnames(mat1) <- cells
  mat1 <- mat1[, cells.1]
  
  knn2 <- buildKNN(data = data, query = data[cells.1, ], k.param = k.param)
  mat2 <- sparseMatrix(p = as.vector(c(0,seq_along(1:length(cells.1))) * k.param ), j = as.vector(t(knn2$idx)), x = 1, dims = c(l1,lc))
  rownames(mat2) <- cells.1
  colnames(mat2) <- cells
  mat2 <- mat2[, cells.2]

  mat <- t(mat1) + mat2
  mat <- mat > 1
  
  rownames(mat) <- cells.1
  colnames(mat) <- cells.2

  mat2@x <- as.vector(t(knn2$dist))

  rm(knn1)
  rm(knn2)

  mat <- mat * mat2
  rm(mat1)
  rm(mat2)

  mat <- drop0(mat)
  mat <- mat[which(rowSums(mat) > 0), which(colSums(mat) > 0)]

  mat@x <- 1/mat@x
  mat <- t(mat)
  W <- mat/rowSums(mat)
  W <- t(W)
  W
}

#' @title FindDEP_v2
#' @description Find different expression pattern of same feature in different cell groups. Only used for integrated data.
#' @param object Seurat object.
#' @param ident.1 Identify class to test, if not set will compare all groups one by one
#' @param ident.2 A second class for comparsion. If NULL (default), use all other cells for comparison.
#' @param cells.1 Vector of cell names belong to group 1. Conflict with ident.1
#' @param cells.2 Vector of cell names for comparsion. Conflict with ident.2
#' @param assay Assay for test features. Default assay will be used if not set.
#' @param reduction Dimension reduction name for constructing SNN graph and weight matrix. Default is 'pca'. This and following parameters only actived when cells is set, because need to recalculate the SNN graph for the defined cells. 
#' @param features Vector of features to calculate. Default is AutoCorrFeatures(object).
#' @param assay Work assay.
#' @param idents Specify idents to compare. If not set will use Idents(object).
#' @param min.cells Features detected in few than minimal number of cells will be skipped. Default is 10.
#' @param layer Data layer to use, default is 'data'.
#' @param perm Permutations for evaluating mean and sd of D scores. Default is 100.
#' @param seed Seed for generate random number. Default is 999.
#' @param threads Threads. If set to 0 (default), will auto check the CPU cores and set threads = number of CPU cores -1.
#' @param versbose Print log message. Default is TRUE.
#' @param debug Print debug message. Will auto set thread to 1. Default is FALSE.
#' @param dims Dimensions of reduction used to construct SNN graph.
#' @param k.param Defines k for the k-nearest neighbor algorithm. In default, k.param = 30
#' @param ... Parameters pass to FindNeighbors().
#' @importFrom Matrix sparseMatrix
#' @export
FindDEP_v2 <- function(object = NULL,
                       ident.1 = NULL,
                       ident.2 = NULL,
                       cells.1 = NULL,
                       cells.2 = NULL,
                       reduction = "pca",
                       features = NULL,
                       assay = NULL,
                       min.cells = 10,
                       layer = "data",
                       perm=100,
                       seed=999,
                       threads = 0,
                       verbose = TRUE,
                       debug = FALSE,
                       dims = 1:20,
                       k.param = 30,
                       labels = c("orphan", "test", "control"),
                       name = "FindDEP.label",
                       prefix = "FindDEP",
                       v2 = TRUE,
                       ...
                       )
{
  if (is.null(object)) stop("No object specified.")

  assay <- assay %||% DefaultAssay(object)
  tt <- Sys.time()
  
  if (!is.null(ident.1) & !is.null(cells.1)) {
    stop("cells.1 is conflict with ident.1.")
  }

  if (!is.null(ident.2) & !is.null(cells.2)) {
    stop("cells.2 is conflict with ident.2.")
  }

  if (!is.null(ident.1)) {
    cells.1 <- colnames(object)[which(Idents(object) == ident.1)]
    if (is.null(cells.1)) stop("No ident.1 found")
  }

  if (!is.null(ident.2)) {
    cells.2 <- colnames(object)[which(Idents(object) == ident.2)]
    if (is.null(cells.2)) stop("No ident.2 found")
  }

  if (is.null(cells.1)) {
    stop("No cells.1 or ident.1 specified.")
  }
  
  features <- features %||% AutoCorrFeatures(object)
  features <- intersect(features, rownames(object))
  
  threads <- getCores(threads)

  if (isTRUE(verbose)) {
    message("Processing ", length(features), " features.")
  }
  
  if (is.null(cells.2)) {
    cells.2 <- setdiff(colnames(object), cells.1)
  }
    
  ValidateCellGroups(object, cells.1, cells.2, min.cells)
  
  dat <- GetAssayData1(object, assay = assay, layer = layer)
  cells <- c(cells.1,cells.2)
  dat <- dat[features,]    
    
  data.use <- Embeddings(object[[reduction]])[, dims]
  if (v2) {
    W <- buildNNWeight_v2(data.use, cells.1, cells.2, k.param)
  } else {
    W <- buildNNWeight(data.use, cells.1, cells.2, k.param)
  }
  
  new.1 <- colnames(W)
  new.2 <- rownames(W)
  dat1 <- dat[, new.1]
  dat2 <- dat[, new.2] 
 
  if ("dgCMatrix" %ni% class(dat1)) {
    dat1 <- as(dat1, "dgCMatrix")
  }

  if ("dgCMatrix" %ni% class(dat2)) {
    dat2 <- as(dat2, "dgCMatrix")
  }

  #dat2 <- dat2 %*% W
  dat2 <- ImputationByWeight(dat2, W = W)
  
  W0 <- GetWeights(emb = data.use[new.1,])

  idx <- 1:length(features)
  ta <- .Call("D_test_v2", dat1, dat2, W0, perm, threads, idx, idx, 0, TRUE, seed, debug)
  
  rm(dat1)
  rm(dat2)
    
  if (length(ta) == 1) stop(ta[[1]])

  e <- ta[[1]]
  tval <- ta[[2]]
  pval <- pt(tval, df = perm - 1, lower.tail = TRUE)
  padj <- p.adjust(pval, method = "BH")
  
  names(e) <- features
  names(pval)<- features
  names(padj) <- features
  df <- Meta(object, assay = assay)
  object[[assay]][[paste0(prefix,".e")]] <- e[rownames(object)]
  object[[assay]][[paste0(prefix,".pval")]] <- pval[rownames(object)]
  object[[assay]][[paste0(prefix,".padj")]] <- padj[rownames(object)]

  rm(ta)
  gc()

  cells <- rep(labels[1], length(cells))
  names(cells) <- colnames(object)
  cells[new.1] <- labels[2]
  cells[new.2] <- labels[3]
  object[[name]] <- cells
  
  features <- head(features)
  object <- LogSeuratCommand(object)
  
  tt <- Sys.time()-tt
  if (isTRUE(verbose)) {
    message("Runtime : ",format(tt), ".");
  }
  
  object
}

#'@export
DEPdemo <- function(object = NULL,
                    ident.1 = NULL,
                    ident.2 = NULL,
                    cells.1 = NULL,
                    cells.2 = NULL,
                    reduction = "pca",
                    feature = NULL,
                    assay = NULL,
                    min.cells = 10,
                    layer = "data",
                    dims = 1:20,
                    k.param = 30)
{
  if (is.null(object)) stop("No object specified.")

  assay <- assay %||% DefaultAssay(object)
  
  if (!is.null(ident.1) & !is.null(cells.1)) {
    stop("cells.1 is conflict with ident.1.")
  }

  if (!is.null(ident.2) & !is.null(cells.2)) {
    stop("cells.2 is conflict with ident.2.")
  }

  if (!is.null(ident.1)) {
    cells.1 <- colnames(object)[which(Idents(object) == ident.1)]
    if (is.null(cells.1)) stop("No ident.1 found")
  }

  if (!is.null(ident.2)) {
    cells.2 <- colnames(object)[which(Idents(object) == ident.2)]
    if (is.null(cells.2)) stop("No ident.2 found")
  }

  if (is.null(cells.1)) {
    stop("No cells.1 or ident.1 specified.")
  }

  if (is.null(feature)) {
    stop("No feature specified")
  }
  
  if (is.null(cells.2)) {
    cells.2 <- setdiff(colnames(object), cells.1)
  }
    
  ValidateCellGroups(object, cells.1, cells.2, min.cells)
  
  dat <- GetAssayData1(object, assay = assay, layer = layer)
  cells <- c(cells.1,cells.2)
    
  data.use <- Embeddings(object[[reduction]])[, dims]

  W <- buildNNWeight(data.use, cells.1, cells.2, k.param)
  new.1 <- colnames(W)
  new.2 <- rownames(W)
  dat <- as.matrix(FetchData(object, vars = feature))
  
  dat1 <- dat[new.1,]
  dat2 <- t(dat[new.2,]) %*% W

  df <- data.frame(ori = as.vector(dat1), smooth = as.vector(dat2))
  rownames(df) <- new.1
  list(df = df, W = W)
}
