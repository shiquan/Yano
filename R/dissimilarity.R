#DScore <- function(x = NULL, y = NULL, W = NULL)
#{
#  d <- .Call("D_score_lite", x, y, W)
#  d
#}

#' @name RunBlockCorr
#' @title Run spatial dissimilarity test for features and their binding features in parallel.
#' @param object Seurat object
#' @param bind.name Title name for binding features in the meta table. Consider most users start Yano to perform alternative splicing analysis, the default bind.name set to "gene_name".
#' @param features Vector of features to calculate. Default is AutoCorrFeatures(object).
#' @param assay Work assay.
#' @param min.cells Features detected in few than minimal number of cells will be skipped. Default is 10.
#' @param bind.assay Name of binding assay.
#' @param bind.features List of bind features. Default use all.
#' @param min.cells.bind Binding features detected in few than minimal number of cells will be skipped. Default is 10.
#' @param prefix Prefix name for output scores and values. Default is same with bind.name.
#' @param subset Rules for subset meta table before select features to perform test.
#' @param scale.factor Scale factor to normalise counts. Default is 1e4. For mode 1, this function will use data from Layer 'data'. For mode 2 and 3, will use data from Layer 'counts'. The counts will further be normalised with sample size and scale factor for spatial dissimilarity test.
#' @param weight.matrix.name Weight matrix name, this matrix (graph) generated by \code{\link{RunAutoCorr}}.
#' @param mode Test mode. For mode 1, X (test feature) vs Y (binding feature). For mode 2, X vs (Y-X). For mode 3, X vs (Y+X). Please note, when set to mode 2 or 3, will use raw counts to update expression value of binding features. Then normalise the counts before testing. For mode 1, will use Layer 'data'. Default is mode 1.
#' @param method Method to use. Support D1, D2 and L. \eqn{D1 = sqrt(L_x)(1-r_xy)}. \eqn{D2 = sqrt(L_x)sqrt(L_y)(1-r_xy)}. L for Lee's Score. In default use D1 method, see the manual for details.
#' @param library.size Library size for each cell, used for normalise counts when mode is 2 or 3. If not set, use colSum(counts) instead.
#' @param scale Scale expression of the test feature and binding feature when perfroming test.
#' @param perm Permutations for evaluating mean and sd of D/L scores. Default is 100.
#' @param seed Seed for generate random number. Default is 999.
#' @param threads Threads. If set to 0 (default), will auto check the CPU cores and set threads = number of CPU cores -1.
#' @param versbose Print log message. Default is TRUE.
#' @importFrom Matrix sparseMatrix
#' @export
RunBlockCorr <- function(object = NULL,
                         bind.name = "gene_name",
                         features = NULL,
                         assay = NULL,
                         min.cells = 10,
                         bind.assay = NULL,
                         bind.features = NULL,
                         min.cells.bind = 10,
                         prefix = NULL,
                         subset = NULL,
                         min.features.per.block = 1,
                         scale.factor = 1e4,
                         mode = c(1,2,3),
                         method = c("D", "D2", "L"),
                         library.size = NULL,
                         scale = FALSE,
                         weight.matrix.name = "WeightMatrix",
                         perm=100,
                         seed=999,
                         threads = 0,
                         block.name = NULL,
                         block.assay = NULL,
                         block.features = NULL,
                         verbose = TRUE,
                         debug = FALSE
                         )
{
  if (!is.null(block.name)) {
    if (isTRUE(verbose)) {
      warning(paste0("'block.name' is deprecated. Set bind.name = '", block.name, "'"))
    }
    bind.name <- block.name
  }
  
  if (!is.null(block.assay)) {
    if (isTRUE(verbose)) {
      warning(paste0("'block.assay' is deprecated. Set bind.assay = '", block.assay, "'"))
    }
    bind.assay <- block.assay
  }

  if (!is.null(block.features)) {
    if (isTRUE(verbose)) {
      warning(paste0("'block.features' is deprecated. Set bind.features = '", block.features, "'"))
    }
    bind.features <- block.features
  }

  if (weight.matrix.name %ni% names(object)) {
    stop("No weight matrix found. Perform RunAutoCorr() first.")
  }

  method <- match.arg(method)
  #mode <- match.arg(mode)
  mode <- mode[1L]
  tt <- Sys.time()

  assay <- assay %||% DefaultAssay(object)
  if (isTRUE(verbose)) {
    message(paste0("Working on assay ", assay))
  }

  if (!is.null(bind.assay)) {
    if (bind.assay %ni% names(object)) {
      stop("No bind.assay is found. Make sure you specify the correct assay name.")
    } else {
      if (isTRUE(verbose)) {
        message(paste0("Working on binding assay ", bind.assay))
      }
    }
  }

  prefix <- prefix %||% bind.name
  
  features <- features %||% AutoCorrFeatures(object)
  features <- intersect(features, rownames(object))

  if (isTRUE(verbose)) {
    message(paste0("Working on ", length(features), " features."))
  }
  threads <- getCores(threads)

  W <- object[[weight.matrix.name]]

  #cells <- cells %||% colnames(object)
  cells <- names(which(rowSums(W) > 0))
  ncell <- length(cells)
  
  object0 <- object[[assay]]
  tab <- object0[[]]

  if (bind.name %ni% colnames(tab)) {
    stop(paste0("No bind.name found in the feature table of assay ", assay, ". Run LoadEPTanno or LoadVARanno first."))
  }

  # skip unannotated records
  tab <- tab[tab[[bind.name]] != "." & !is.na(tab[[bind.name]]),] 
  
  if (!is.null(subset)) {
    tab <- base::subset(tab, subset = subset)
  }
  
  blocks <- names(which(table(tab[[bind.name]]) >= min.features.per.block))

  bind.features <- bind.features %||% blocks
  blocks <- intersect(bind.features, blocks)
  features <- intersect(features, rownames(tab))

  if (length(features) == 0) {
    stop("No features found.")
  }
  
  idx <- match(features, rownames(tab))
  tab0 <- tab[idx,]
  blocks <- intersect(unique(tab0[[bind.name]]), blocks)

  if (isTRUE(verbose)) {
    message(paste0("Processing ", length(blocks), " blocks.."))
  }
  tab <- subset(tab, tab[[bind.name]] %in% blocks)
  features <- intersect(features, rownames(tab))

  x <- GetAssayData1(object, assay = assay, layer = "counts")
  
  cs <- library.size %||% colSums(x)

  norm <- TRUE

  bind.assay <- bind.assay %||% "tmp.assay"

  if (bind.assay %ni% names(object)) {

    if (min.features.per.block == 1) {
      if (isTRUE(verbose)) {
        message("No bind.assay specified, update min.features.per.block to 2.")
      }
      min.features.per.block <- 2
      blocks <- names(which(table(tab[[bind.name]]) >= min.features.per.block))
      tab <- subset(tab, tab[[bind.name]] %in% blocks)
      features <- intersect(features, rownames(tab))
    }

    x <- x[,cells]

    rs <- Matrix::rowSums(x>0)
    idx <- which(rs >= min.cells)
    features1 <- rownames(object)[idx]
    features <- intersect(features, features1)
    
    cs <- cs[cells]
    W <- W[cells,cells]
    if (isTRUE(verbose)) {
      message("Aggregate counts..")
    }
    x0 <- x[rownames(tab),cells]
    x0 <- as(x0, "TsparseMatrix")
    
    # Aggregate features in the same block
    y <- sparseMatrix(i = match(tab[[bind.name]][x0@i+1], blocks),
                      j = x0@j+1,
                      x = x0@x, dims=c(length(blocks), length(cells)))

    rm(x0)
    rownames(y) <- blocks
    colnames(y) <- cells
  } else {
    x <- x[,cells]
    W <- W[cells,cells]
    cs <- cs[cells]
    
    rs <- Matrix::rowSums(x>0)
    idx <- which(rs >= min.cells)
    features1 <- rownames(object)[idx]
    features <- intersect(features, features1)

    blocks <- unique(tab[[bind.name]])
    if (isTRUE(verbose)) {
      message(paste0("Trying to retrieve data from assay ", bind.assay,".."))
    }
    old.assay <- DefaultAssay(object)
    DefaultAssay(object) <- bind.assay
    blocks <- intersect(blocks, rownames(object))

    y <- GetAssayData1(object, assay = bind.assay, slot = "counts")
    y <- y[,cells]

    rs <- Matrix::rowSums(y>0)
    idx <- which(rs >= min.cells.bind)
    blocks1 <- rownames(object)[idx]
    blocks <- intersect(blocks, blocks1)

    tab <- subset(tab, tab[[bind.name]] %in% blocks)
    
    DefaultAssay(object) <- old.assay
  }

  features <- intersect(features, rownames(tab))
  tab <- tab[features,]
  bidx <- match(tab[[bind.name]],rownames(y))
  idx <- match(features, rownames(x))
  if (isTRUE(verbose)) {
    message(paste0("Test dissimlarity of binding features with ", threads, " threads."))
  }
  gc()

  if (isTRUE(verbose)) {
    message(paste0("Use method \"", method, "\" with mode ", mode))
  }
  method <- switch(method, "D" = 1, "D2" = 2, "L" == 3)
  ta <- .Call("D_test", x, y, W, method, perm, threads, idx, bidx, cs, scale.factor, mode, scale, norm, seed, debug);
  
  if (length(ta) == 1) stop(ta[[1]])

  r <- ta[[1]]
  e <- ta[[2]]
  tval <- ta[[3]]
  mval <- ta[[4]]
  vval <- ta[[5]]
  
  names(r) <- features
  names(e) <- features
  names(mval) <- features
  names(vval) <- features
  
  pval <- pt(tval, df = perm - 1, lower.tail = FALSE)
  names(pval) <- features
  tab <- object[[assay]][[]]
  if (method == 1) {
    prefix <- paste0(prefix, ".D")
  } else if (method == 2) {
    prefix <- paste0(prefix, ".D2")
  } else if (method == 3) {
    prefix <- paste0(prefix, ".L")
  }
  tab[[prefix]] <- e[rownames(object)]
  tab[[paste0(prefix, ".r")]] <- r[rownames(object)]
  tab[[paste0(prefix, ".pval")]] <- pval[rownames(object)]
  tab[[paste0(prefix, ".mean")]] <- mval[rownames(object)]
  tab[[paste0(prefix, ".var")]] <- vval[rownames(object)]
  tab[[paste0(prefix, ".padj")]] <- p.adjust(pval[rownames(object)], method = "BH")
  object0[[colnames(tab)]] <- tab

  object[[assay]] <- object0

  rm(ta)
  gc()

  features <- head(features)
  object <- LogSeuratCommand(object)
  
  tt <- Sys.time()-tt
  if (isTRUE(verbose)) {
    message(paste0("Runtime : ",format(tt)));
  }
  object
}

cor_dist <- function(x = NULL, y = NULL, W = NULL, perm = 1000, thread = 1)
{
  ta <- .Call("D_distribution_test", x, y, W, perm, thread)
  ta
}

#' @export
SDTdemo <- function(object = NULL, bind.name = NULL, bind.assay = NULL, assay = NULL, mode = c(1,2,3), perm = 100, feature = NULL) {
  
  if (is.null(object)) {
    stop("No object.")
  }

  if (is.null(feature)) {
    stop("No feature.")
  }

  if (is.null(bind.name)) {
    stop("bind.name is not set.")
  }
  assay <- assay %||% DefaultAssay(object)
  old.assay <- DefaultAssay(object)

  DefaultAssay(object) <- assay
  feature <- intersect(rownames(object), feature)

  if (length(feature) == 0) {
    stop("No feature found.")
  }

  df <- object[[assay]][[]]

  if (!(bind.name %in% colnames(df))) {
    stop("No bind.name found.")
  }

  bind.feature <- df[feature, bind.name]

  if (is.na(bind.feature)) {
    stop("bind.feature is NA.")
  }

  x <- GetAssayData(object, layer = "counts")
  cs <- colSums(x)
  
  d1 <- x[feature,]

  d1 <- as.matrix(d1)
  DefaultAssay(object) <- bind.assay

  bind.feature <- intersect(bind.feature, rownames(object))
  if (length(bind.feature) == 0) {
    stop("No bind.feature found.")
  }

  d2 <- GetAssayData(object, layer="counts")[bind.feature,]
  d2 <- as.matrix(d2)
  if (mode ==  2) {
    d2 <- d2 - d1
  }
  if (mode == 3) {
    d2 <- d1 + d2
  }
  
  message(paste0("Orginal cor is ", cor(d1[,1], d2[,1])))

  d1[,1] <- log(d1[,1]*1e4/cs+1)
  d2[,1] <- log(d2[,1]*1e4/cs+1)
  
  message(paste0("Cor after normlise is ", cor(d1[,1], d2[,1])))
  message(paste0("Mean a ", mean(d1[,1]), " mean b ", mean(d2[,1])))
  
  W <- object[['WeightMatrix']]
  W <- as(W, "CsparseMatrix")

  s1 <- (d1[,1] %*% W)[1,]
  s2 <- (d2[,1] %*% W)[1,]
  
  message(paste0("Cor after smooth is ", cor(s1, s2)))
  message(paste0("Mean smooth a ", mean(s1), " mean smooth b ", mean(s2)))
  d1 <- d1[,1]
  sm <- mean(d1)
  
  Lx <- sum((s1-sm)^2)/sum((d1-sm)^2)
  
  D <- sqrt(Lx)*(1-cor(s1,s2))

  mn <- lapply(1:perm, function(i) {
    d11 <- sample(d1)
    s11 <- (d11 %*% W)[1,]
    Lx1 <- sum((s11-sm)^2)/sum((d11-sm)^2)
    sqrt(Lx1)*(1-cor(s11,s2))    
  })

  mn <- unlist(mn)
  hist(mn)
  m <- mean(mn)
  var <- sqrt(sum((mn - m)^2)/perm)
  t <- (D-m)/var
  
  p <- pt(t, df = perm-1, lower.tail = FALSE)
  message(paste0("Lx is ", Lx, ", D score is ", D))
  message(paste0("Mean is ", m, ", var is ", var))
  message(paste0("t value is ", t, ";\np value is ", p))

  DefaultAssay(object) <- old.assay
}

